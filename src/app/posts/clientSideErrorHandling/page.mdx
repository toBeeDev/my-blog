import ArticleLayout from "@/shared/components/article/ArticleLayout";

export const article = {
  author: "Bee",
  date: "2025-02-05",
  title: "âš ï¸ Client Side Error Handling",
  description: "Client Side Error Handling ì— ëŒ€í•œ ì •ë¦¬ë¥¼ ìœ„í•œ ê¸€",
};

export const metadata = {
  title: article.title,
  description: article.description,
};

export default (props) => <ArticleLayout article={article} {...props} />;

<aside>
ğŸ’¡ Client Side Error Handling ì— ëŒ€í•œ ì •ë¦¬ë¥¼ ìœ„í•œ ê¸€

</aside>

## Why?

1ì°¨ì ìœ¼ë¡œ ìµœê·¼ RollBarë¥¼ í†µí•´ ë¡œê¹… ë˜ëŠ” ì—ëŸ¬ì— ëŒ€í•œ í•¸ë“¤ë§ì„ ì‹œì‘í•˜ê²Œ ë˜ë©°, ê°œì¸ì ìœ¼ë¡œ ê³µë¶€ë¥¼ ìœ„í•œ í”„ë¡œì íŠ¸ í˜¹ì€ í¬íŠ¸í´ë¦¬ì˜¤ì— ë‹´ì•˜ë˜ ëª¨ë“  ì½”ë“œì—ì„œëŠ” ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ ë‹¨ì§€ `console.log`ì— í‘œì¶œì„ í•˜ê±°ë‚˜ ê·¸ëƒ¥ `throw new Error()` ë¥¼ í†µí•´ ì—ëŸ¬í•¸ë“¤ë§ì„ í–ˆì—ˆëŠ”ë°, ë§‰ìƒ productionì— ë‚˜ê°€ëŠ” í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ê²Œ ë˜ë‹ˆ ì—ëŸ¬ë¡œê¹…ê³¼ ì—ëŸ¬í•¸ë“¤ë§ì´ ì–¼ë§ˆë‚˜ ì¤‘ìš”í•œê°€ì— ëŒ€í•´ ê¹¨ë‹¬ì„ ìˆ˜ ìˆì—ˆê³  ì´ë¥¼ ì •ë¦¬í•˜ê³ ì ì‘ì„±í•˜ê²Œ ë˜ì—ˆë‹¤.

## How?

### Client Side (Feat. Axios)

> Axios : ë¸Œë¼ìš°ì €, Node.jsë¥¼ ìœ„í•œ Promise APIë¥¼ í™œìš©í•˜ëŠ” HTTP ë¹„ë™ê¸° í†µì‹  ë¼ì´ë¸ŒëŸ¬ë¦¬

[Axios](https://axios-http.com/kr/docs/intro)ë¥¼ í™œìš©í•˜ì—¬ Client Side Componentì—ì„œì˜ HTTP ë¹„ë™ê¸° í†µì‹ ì„ ì§„í–‰í•˜ì˜€ê³ , ê³¼ì • ì†ì—ì„œ ê° status ì— ë”°ë¥¸ Error instanceë¥¼ ìƒì„±í•˜ê³ , í•´ë‹¹ instanceëŠ” AxiosErrorë¥¼ extends(í™•ì¥) í•˜ì—¬ íŠ¹ì • ìš”ì†Œë“¤ì„ ê°’ìœ¼ë¡œ ë°›ì•„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ êµ¬ì„±í•˜ì˜€ë‹¤.

```tsx
//ClientRequestError instanceìƒì„±
export class ClientRequestError extends AxiosError {
  // @ts-expect-error AxiosErrorì˜ codeëŠ” string
  code: number
  withCredentials: boolean
  timeout: number
  readyState: number
  status: number
  statusText: string
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  response: any
  responseText: string
  responseURL: string
  responseType: XMLHttpRequestResponseType
  axiosResponse: AxiosResponse | undefined

  constructor(message: string, code: number, response: AxiosResponse | undefined, request: XMLHttpRequest) {
    super(message)
    this.code = code
    this.axiosResponse = response
    this.withCredentials = request.withCredentials
    this.timeout = request.timeout
    this.readyState = request.readyState
    this.status = request.status
    this.statusText = request.statusText
    this.response = request.response
    this.responseText = request.responseText
    this.responseURL = request.responseURL
    this.responseType = request.responseType
  }
}
...ServerRequestError
export class NetworkRequestError extends AxiosError {
	axiosResponse: AxiosResponse | undefined
	constructor(message:string, response: AxiosResponse | undefined,request: XMLHttpRequest ){
	super(message)
	this.axiosResponse = response
	this.response = request.response
	this.request = request
	}
}
...UnhandledRequestError
////////
```

Axios Interceptorì—ì„œ íŠ¹ì • ì¡°ê±´ì— ë”°ë¼ Error Handlingì„ ì§„í–‰í•˜ëŠ” ë¡œì§ì„ êµ¬ì„±í•˜ì˜€ë‹¤. 1ì°¨ì ìœ¼ë¡œ NetworkError, ServerError, ClientError, UnhandledError ë¡œ Errorë¥¼ êµ¬ë¶„ì§€ì—ˆê³  ì´ë¥¼ ì•„ë˜ì™€ ê°™ì´ í™œìš©í•˜ì˜€ë‹¤.

```tsx
//index.ts
const handleNetworkError = (error: AxiosError<ErrorResData>) => {
  //ê¸°ì¡´ ë¡œì§
  const errMsg = error.message ?? NETWORK_ERROR_MSG;
  const clientRequestNetworkError = new NetworkError(
    errMsg,
    error.response,
    error.request
  );
  return Promise.reject(networkError);
};

const handleServerInternalError = (
  response: AxiosResponse<ErrorResData>,
  error: AxiosError<ErrorResData>
) => {
  const message =
    response.status != serviceUnavailableStatusCode
      ? SERVER_ERROR_MSG
      : TEMP_SERVER_ERROR_MSG;
  const serviceInternalError = new ServerInternalError(
    message,
    error.response,
    error.request
  );
  return Promise.reject(serviceInternalError);
};

const handleClientRequestError = (
  response: AxiosResponse<ErrorResData>,
  error: AxiosError<ErrorResData>
) => {
  const errorMsg = response.data.error.message ?? CLIENT_ERROR_MSG;
  const errorCode = response.data.error.code ?? 0;
  const clientRequestError = new ClientRequestError(
    errorMsg,
    errorCode,
    error.response,
    error.request
  );
  return Promise.reject(clientRequestError);
};

const unhandledError = (error: Error) => {
  const unhandledError = new Shared.Errors.UnknownError(error.message);
  return Promise.reject(unhandledError);
};

axios.interceptors.response.use(
  (res) => res,
  //Error - unhandledError
  //AxiosError - AxiosError
  (error: Error | AxiosError) => {
    if (isAxiosError<ErrorResData>(error)) {
      const response = error.response;
      //response ì—†ì„ ê²½ìš°(ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬)
      if (!response) {
        return handleNetworkError(error);
      }
      //5xxëŒ€ ì—ëŸ¬ í•¸ë“¤ë§
      if (error.response && server5xxStatusCode <= error.response.status) {
        return handleServerInternalError(response, error);
      }
      //4xxëŒ€ ì—ëŸ¬ í•¸ë“¤ë§
      if (error.response && client4xxStatusCode <= error.response.status) {
        return handleClientRequestError(response, error);
      }
    }
    //Unknown ì—ëŸ¬ í•¸ë“¤ë§
    return unhandledError(error);
  }
);
```

ë‹¤ìŒ ê¸€ì—ì„œëŠ” Fetch & Axios Error Handlingë¡œ ë§ˆë¬´ë¦¬ë¥¼ ì§€ì–´ë³´ë ¤í•œë‹¤.
